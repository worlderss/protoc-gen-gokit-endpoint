package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

// main is the entry point for the application.
func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generate(gen, f)
		}
		return nil
	})
}

// generate takes plugin and file as input, then output the generated file
func generate(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_endpoints.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	// 写入一些警告之类的 告诉用户不要修改
	g.P("// Code generated by protoc-gen-gokit-endpoint. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// protoc-gen-gokit-endpoint %s", version))
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		generateForService(g, service)
		generateServer(g, service)
	}

	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "context"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "github.com/go-kit/kit/endpoint"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "github.com/go-kit/kit/transport/grpc"})
	return g
}

func generateForService(file *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			continue
		}
		generateGokitEndpoint(file, service, method)
		generateEncoderDecoder(file, service, method)
		generateHandler(file, service, method)
	}
}

func generateGokitEndpoint(file *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	file.P(fmt.Sprintf("func make%sEndpoint(s %sServer) endpoint.Endpoint {", method.GoName, service.GoName))
	file.P("\treturn func(ctx context.Context, request interface{}) (interface{}, error) {")
	file.P(fmt.Sprintf("\t\treq := request.(*%s)", method.Input.GoIdent.GoName))
	file.P(fmt.Sprintf("\t\treturn s.%s(ctx, req)", method.GoName))
	file.P("\t}")
	file.P("}")
}

func generateEncoderDecoder(file *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	file.P(fmt.Sprintf("func decode%sRequest(_ context.Context, req interface{}) (interface{}, error) {", method.GoName))
	file.P("\treturn req, nil")
	file.P("}")

	file.P(fmt.Sprintf("func encode%sResponse(_ context.Context, rsp interface{}) (interface{}, error) {", method.GoName))
	file.P("\treturn rsp, nil")
	file.P("}")
}

func generateHandler(file *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	file.P(fmt.Sprintf("func Make%sHandler(s %sServer) *grpc.Server {", method.GoName, service.GoName))
	file.P(fmt.Sprintf("\treturn grpc.NewServer(make%sEndpoint(s), decode%sRequest, encode%sResponse )", method.GoName, method.GoName, method.GoName))
	file.P("}")
}

func generateServer(file *protogen.GeneratedFile, service *protogen.Service) {
	file.P(fmt.Sprintf("type %s struct {", service.GoName))
	file.P(fmt.Sprintf("\tUnimplemented%sServer", service.GoName))
	file.P(fmt.Sprintf("\tservice %sServer", service.GoName))

	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			continue
		}
		file.P(fmt.Sprintf("\t\t%sHandler grpc.Handler", method.GoName))
	}
	file.P("}")

	file.P(fmt.Sprintf("func New%s(s %sServer) *%s {", service.GoName, service.GoName, service.GoName))
	file.P(fmt.Sprintf("\treturn &%s{", service.GoName))
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			continue
		}
		file.P(fmt.Sprintf("\t\t%sHandler: Make%sHandler(s),", method.GoName, method.GoName))
	}
	file.P("\t}")
	file.P("}")

	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			continue
		}
		file.P(fmt.Sprintf("func (s *%s) %s(ctx context.Context, req *%s) (*%s, error) {", service.GoName, method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
		file.P(fmt.Sprintf("\t_, response, err := s.%sHandler.ServeGRPC(ctx, req)", method.GoName))
		file.P("\tif err != nil {")
		file.P("\t\treturn nil, err")
		file.P("\t}")
		file.P(fmt.Sprintf("\treturn response.(*%s), nil", method.Output.GoIdent.GoName))
		file.P("}")
		//generateGokitEndpoint(file, service, method)
		//generateEncoderDecoder(file, service, method)
		//generateHandler(file, service, method)
	}
}

//
//func generateController(file *protogen.GeneratedFile, service *protogen.Service) {
//    file.P(fmt.Sprintf("type %sController struct {", service.GoName))
//    file.P(fmt.Sprintf("\tserver %sServer", service.GoName))
//    // writing GetControllerType function
//    //file.P(fmt.Sprintf("    GetControllerType() reflect.Type"))
//    // walk through all the service method and generate function
//    for _, method := range service.Methods {
//        if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
//            continue
//        }
//        file.P(fmt.Sprintf("    %s func(ctx *http.Context) `%s`",
//            method.GoName,
//            getMethodTag(method)))
//    }
//    file.P("}\n\n")
//    generateConstructor(file, service)
//    file.P("\n\n")
//    generateInterfaceImplement(file, service)
//    if *enableRpc {
//        generateRpcClient(file, service)
//    }
//}
//
//// generateMethodTags  will accept the method and generate the tags for the method
//func getMethodTag(method *protogen.Method) string {
//    value := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
//    rule := value.(*annotations.HttpRule)
//    if rule != nil {
//        path, method := resolveHttpMethod(rule)
//        // TODO: 解析参数
//        return fmt.Sprintf("method:\"%s\" route:\"%s\" param:\"input\"", method, path)
//    }
//    return fmt.Sprintf("method:\"GET\"")
//}
//
//func resolveHttpMethod(rule *annotations.HttpRule) (string, string) {
//    var path string
//    var method string
//    switch pattern := rule.Pattern.(type) {
//    case *annotations.HttpRule_Get:
//        path = pattern.Get
//        method = "GET"
//    case *annotations.HttpRule_Put:
//        path = pattern.Put
//        method = "PUT"
//    case *annotations.HttpRule_Post:
//        path = pattern.Post
//        method = "POST"
//    case *annotations.HttpRule_Delete:
//        path = pattern.Delete
//        method = "DELETE"
//    case *annotations.HttpRule_Patch:
//        path = pattern.Patch
//        method = "PATCH"
//    case *annotations.HttpRule_Custom:
//        path = pattern.Custom.Path
//        method = pattern.Custom.Kind
//    }
//    return path, method
//}
//
//func generateConstructor(file *protogen.GeneratedFile, service *protogen.Service) {
//    file.P(fmt.Sprintf("func New%sController(server %sServer) *%sController {",
//        service.GoName,
//        service.GoName,
//        service.GoName))
//    file.P(fmt.Sprintf("    return &%sController{server: server}", service.GoName))
//    file.P("}")
//}
//
//func generateInterfaceImplement(file *protogen.GeneratedFile, service *protogen.Service) {
//    file.P(fmt.Sprintf("func (c *%sController) GetControllerType() reflect.Type {", service.GoName))
//    file.P(fmt.Sprintf("    return reflect.TypeOf(*c)"))
//    file.P("}")
//}
